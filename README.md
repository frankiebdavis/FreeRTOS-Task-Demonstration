# 🧠 FreeRTOS Task Scheduling Demo – STM32F303RE

This project demonstrates how **FreeRTOS** enables multitasking on the STM32F303RE Nucleo board. It highlights how task priorities and scheduling policies can be used to control task behavior — something that isn't possible with traditional sequential microcontroller code.

Whether you're building real-time systems or trying to improve embedded firmware structure, this project serves as a practical showcase of why RTOS-based development is a step above bare-metal looping.

---

## 🎯 Project Goal

To demonstrate how FreeRTOS enables:

- Cooperative multitasking using delays
- Controlled task scheduling through priority settings
- Task management features like runtime termination

---

## 🔧 Hardware Used

- STM32F303RE Nucleo Board  
- USB cable for power/debug (ST-Link interface)  
- Host PC running STM32CubeIDE  

---

## 🚦 What This Project Does

This demo uses **two FreeRTOS tasks**, `Task1` and `Task2`, that each print a line to the debug console. Depending on how task priorities are configured or modified, the output behavior changes.

The output is captured using **ITM/SWO print debugging** — viewable in STM32CubeIDE under the SWV ITM Console.

---

## 📊 Demo Scenarios

### ✅ 1. **Default: Task1 Runs First**
- `Task1`: priorityNormal  
- `Task2`: priorityLow

🔁 Output:
```
Task 1
Task 2
Task 1
Task 2
...
```

This shows how higher-priority tasks preempt lower ones, but both still share time via `osDelay()`.

---

### ✅ 2. **Priority Flip: Task2 Runs First**
- `Task1`: priorityLow  
- `Task2`: priorityNormal

🔁 Output:
```
Task 2
Task 1
Task 2
Task 1
...
```

A simple priority change completely reverses the execution order — no changes needed to task logic itself.

---

### ✅ 3. **Task2 Terminates Task1**
Inside `Task2`, we call `osThreadTerminate(Task1Handle);` after the first round.

🔁 Output:
```
Task 1
Task 2
Task 2
Task 2
...
```

This demonstrates how FreeRTOS allows one task to control another — enabling dynamic behavior that isn’t possible in a blocking `while(1)` loop model.

---

## 💻 How It Works

Tasks are created in `main.c` using `osThreadNew()` with assigned priorities. Each task prints its name and delays for 1 second.

```c
Task1Handle = osThreadNew(StartTask1, NULL, &Task1_attributes);
Task2Handle = osThreadNew(StartTask2, NULL, &Task2_attributes);
```

Inside each task function:

```c
void StartTask1(void *argument) {
    for (;;) {
        printf("Task 1\n");
        osDelay(1000);
    }
}
```

```c
void StartTask2(void *argument) {
    for (;;) {
        printf("Task 2\n");
        osDelay(1000);
        osThreadTerminate(Task1Handle); // Terminates Task1 after the first run
    }
}
```

Output is printed over **ITM debug channel (SWO)** using `printf()` mapped to `ITM_SendChar()` via `syscalls.c`.

---

## 🧠 Why FreeRTOS?

This project highlights why using an RTOS like FreeRTOS provides major advantages:

| Feature                  | Bare-Metal | FreeRTOS |
|--------------------------|------------|----------|
| Multiple concurrent tasks | ❌ No       | ✅ Yes    |
| Task priority control     | ❌ No       | ✅ Yes    |
| Clean code organization   | ❌ Usually messy | ✅ Tasks stay modular |
| Runtime task termination  | ❌ Manual logic | ✅ Built-in |

Even with just two tasks, this project demonstrates how FreeRTOS gives you **greater control, flexibility, and maintainability** in embedded systems development.

---

## 📄 License

This project uses code generated by STM32CubeMX and may contain code under the STMicroelectronics license.

MIT License applies to all original contributions unless otherwise stated.
